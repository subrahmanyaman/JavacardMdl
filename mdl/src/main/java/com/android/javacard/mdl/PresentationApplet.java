package com.android.javacard.mdl;

import com.android.javacard.mdl.jcardsim.SEProvider;
import javacard.framework.AID;
import javacard.framework.JCSystem;
import javacard.framework.Shareable;
import javacard.framework.APDU;
import javacard.framework.Applet;
import javacard.framework.ISO7816;
import javacard.framework.ISOException;
import javacardx.apdu.ExtendedLength;
import javacard.framework.Util;

/**
 * This applet is responsible to serve the reader's request for the Mdl Document. This applet
 * executes all the security controls, data processing & validation and NFC protocol specified in
 * ISO 18013-5 specs.
 * It also is the store for the presentation packages provisioned by the provisioning applet.
 */
public class PresentationApplet extends Applet implements ExtendedLength, MdlService {
  public static final byte[] AID_MDL_DIRECT_ACCESS_APPLET = {
      (byte) 0xA0, 0x00, 0x00, 0x02, 0x48, 0x04, 0x00};
  private static final byte INVALID_VALUE = -1;
  private static final byte MAX_DOCUMENTS_SLOTS = 1;
  public final static byte INS_ENVELOPE = (byte) 0xC3;
  public final static byte INS_GET_RESPONSE = (byte) 0xC0;
  private static final byte MDOC_TYPE_LEN = 30;
  private static final byte MDOC_ID_LEN = 4;
  // counter values
  private static final byte READER_MSG_COUNTER = 0;
  private static final byte DEVICE_MSG_COUNTER = 1;
  public static final byte[] AID_NDEF_TAG_APPLET = {(byte) 0xD2, 0x76, 0x00, 0x00, (byte) 0x85,
      0x01, 0x01};

  // The NDEF Data File is Handover Select Message, which consists of 3 records as follows:
  // 1. Handover Select Record, that consists of Alternative Carrier Record consisting of
  // first a CDR pointing to the "nfc "Carrier Configuration NDEF Record and secondly an Auxiliary
  // Record "mdoc" NDEF record.
  //
  // 2. The "nfc" Carrier Configuration NDEF Record provides three fields record of nfc type, max
  // command size and max response size. This record is pointed by CDR.
  // All the above messages are NDEF encoded and hardcoded, except the part of "mdoc" NDEF
  // record that contains Device engagement data, which is referenced by the fixed offset.
  //
  // 3. The "mdoc" NDEF Record, which contains the CBOR encoded Device Engagement data which is
  // generated by MDL Applet. This data is accessed by this applet using MDL Applet's Shareable
  // interface.

  static  final short MAX_RESPONSE_SIZE = 0x7FFF;
  static final byte[] HANDOVER_MSG_FIXED_PART = {
      // 1. Handover Select Record - size = 3 + 2 + 17 = 22
      // Refer nfcCalculateHandover in com.android.identity.PresentationHelper
      // NDEF Header
      (byte) 0b10010001, //MB=1, ME=0, CF=0, SR=1, IL=0, TNF= 1 (Well Known Type)
      // Lengths
      (byte) 2, // length of "Hs" type
      (byte) 17, //Size of "Hs" payload
      0x48, 0x73, // // Value of UTF-8 encoded "Hs" type,
      // Payload - Handover Select Record Payload
      // Refer nfcCalculateStaticHandoverSelectPayload in com.android.identity.DataTransferNfc
      0x15, // Major and Minor Version of connection handover specs i.e. 1.5
      // Alternative Carrier Record - only one record
      // NDEF Header
      (byte) 0b11010001, //MB=1, ME=1, CF=0, SR=1, IL=0, TNF= 1 (Well Known Type)
      // Lengths
      (byte) 2, // length of "ac" type
      (byte) 11, //Size of "ac" payload
      0x61, 0x63, // Value of UTF-8 encoded "ac" type,
      // Payload - AC record payload
      // Refer to createNdefRecord method in com.android.identity.DataTransferNfc
      // Header
      0x01, // RFU = 0, CPS = 1 (ACTIVE)
      // CDR
      0x03, // Length of "nfc" configuration record reference chars
      0x6E, 0x66, 0x63, // Value of UTF-8 encoded "nfc" Id
      // Aux Record
      0x01, // Number of auxiliary record is 1 as only "mdoc" is required
      0x04, // Length of "mdoc" record reference chars
      0x6d, 0x64, 0x6f, 0x63, // Value of UTF-8 encoded "mdoc" id.

      // 2. "nfc" Carrier Configuration Record - size = 4 +17 + 9 + 3 = 33
      // Refer to createNdefRecord method in com.android.identity.DataTransferNfc
      // NDEF Header
      (byte) 0b00011010, //MB=0, ME=0, CF=0, SR=1, IL=1, TNF= 2 (MIME)
      // Lengths
      (byte) 17, // length of "iso.org:18013:nfc" type
      (byte) 9, //Size of payload
      (byte) 3, //size of id i.e. "nfc"
      //Value of UTF-8 encoded "iso.org:18013:nfc" type
      0x69, 0x73, 0x6F, 0x2E, 0x6F, 0x72, 0x67, 0x3A, 0x31, 0x38, 0x30, 0x31, 0x33, 0x3A, 0x6E,
      0x66, 0x63,
      0x6E, 0x66, 0x63, // Value of UTF-8 encoded "nfc" Id 21+9
      //Payload Configuration record as defined in ISO18013 - section 8.2.2.2
      0x01, // version
      0x03, // Data length of the max command size
      0x01, // Data type of the max command size
      (byte) ((Context.MAX_BUF_SIZE >> 8) & 0x00FF), (byte) (Context.MAX_BUF_SIZE & 0x00FF),
      // Max Cmd Size
      0x03, // Data length of the max response size
      0x02, // Data type of the max response size
      (byte) ((Context.MAX_BUF_SIZE >> 8) & 0x00FF), (byte) (Context.MAX_BUF_SIZE & 0x00FF),
      // Max response Size

      // 3. "mdoc" NDEF Record - start = 33 + 22 + 2= 57
      // Refer nfcCalculateHandover in com.android.identity.PresentationHelper
      // NDEF Header - HEADER OFFSET = PAYLOAD_LEN_OFFSET - 2
      (byte) 0b01011100, //MB=0, ME=0, CF=0, SR=1, IL=1, TNF= 4 (External)
      // Lengths
      (byte) 30, // length of "iso.org:18013:deviceengagement" type
      //Size of Payload - PAYLOAD_LEN_OFFSET = PAYLOAD OFFSET - MDOC_ID_LEN - MDOC_TYPE_LEN - 2
      INVALID_VALUE,
      (byte) 4, //size of id i.e. "mdoc"
      // Type Value - UTF-8 encoded  "iso.org:18013:deviceengagement"
      0x69, 0x73, 0x6F, 0x2E, 0x6F, 0x72, 0x67, 0x3A, 0x31, 0x38, 0x30, 0x31, 0x33,
      0x3A, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x65, 0x6E, 0x67, 0x61, 0x67, 0x65,
      0x6D, 0x65, 0x6E, 0x74,
      // Id Value - UTF-8 encoded "mdoc"
      0x6d, 0x64, 0x6f, 0x63,
      // Payload - PAYLOAD OFFSET = FIXED PART size
  };

  // This is the fixed part of Device Management data.
  // Note: For NFC we don't have device retrieval methods given in this structure. It is
  // exchanged in Handover Select Message's alternate carrier records.
  // Refer  generateDeviceEngagement in com.android.identity.PresentationHelper
  public static final byte[] DEVICE_ENGAGEMENT_FIXED = {
      // CBOR Map of two elements
      (byte) (MdlSpecifications.CBOR_MAP | 0x02),
      // 0: text string of 3 chars containing "1.0" version.
      0x00, (byte) (MdlSpecifications.CBOR_TEXT_STR | 0x03), 0x31, 0x2E, 0x30,
      // 1: security data item which is an CBOR array of two elements
      0x01, (byte) (MdlSpecifications.CBOR_ARRAY | 0x02),
      // First element of the security data item array is cipher suite 1 (CBOR unsigned int)
      // unsigned int of value 1
      0x01,
      // Second element is Semantic tag 6.24 - Note as tag val (unsigned int 24 = 0x18) > 23 the
      // Semantic tag
      // uses the short encoding and not tiny encoding.
      (byte) (byte) (MdlSpecifications.CBOR_SEMANTIC_TAG | MdlSpecifications.CBOR_UINT8_LENGTH),
      MdlSpecifications.CBOR_SEMANTIC_TAG_ENCODED_CBOR,
      // Data following this is generated in getNfcDeviceEngagementData method.
  };
  // Count of messages received from reader in an active session. This is used to decrypt and
  // encrypt the request and response to and from the reader.
  private static short[] mMsgCounter;
  // Following is used to return multiple values
  private static short[] mRetVal;
  // Following is used to decode the request
  private static short[] mStructure;
  // Cbor Decoder
  private static CBORDecoder mDecoder;
  // Cbor Encoder
  private static CBOREncoder mEncoder;
  // Store of presentation package. Currently, stores only one package.
  private static PresentationPkgStore mPresentationPkgStore;
  // Scratch pad of 512 bytes. Used to store intermediate data.
  private static byte[] mScratchPad;
  private static Context mContext;
  static CBOREncoderCalc mCalculator;
  // Install
  public static void install(byte[] bArray, short bOffset, byte bLength) {
    mDecoder = new CBORDecoder();
    mEncoder = new CBOREncoder();
    mCalculator = new CBOREncoderCalc();
    mContext = new Context();

    mScratchPad = JCSystem.makeTransientByteArray((short) 512, JCSystem.CLEAR_ON_DESELECT);
    mContext.init(JCSystem.makeTransientByteArray(Context.MAX_BUF_SIZE, JCSystem.CLEAR_ON_DESELECT));
    mRetVal = JCSystem.makeTransientShortArray((short) 5, JCSystem.CLEAR_ON_DESELECT);
    mStructure = JCSystem.makeTransientShortArray((short) 30, JCSystem.CLEAR_ON_DESELECT);
    mRetVal = JCSystem.makeTransientShortArray((short) 10, JCSystem.CLEAR_ON_DESELECT);
    mStructure = JCSystem.makeTransientShortArray((short) 10, JCSystem.CLEAR_ON_DESELECT);
    mMsgCounter = JCSystem.makeTransientShortArray((short) 2, JCSystem.CLEAR_ON_RESET);

    mMsgCounter[READER_MSG_COUNTER] = 1;
    mMsgCounter[DEVICE_MSG_COUNTER] = 1;

    Session.init();
    mPresentationPkgStore = PresentationPkgStore.instance();
    mPresentationPkgStore.configure(MAX_DOCUMENTS_SLOTS, (byte) 1, (short) 0x7FFF);

    reset();
    new PresentationApplet().register();
  }
  static void reset() {
    mContext.reset();
    Session.reset();
    short i = (byte) mStructure.length;
    while (i > 0) {
      mStructure[--i] = INVALID_VALUE;
    }
    i = (byte) mRetVal.length;
    while (i > 0) {
      mRetVal[--i] = INVALID_VALUE;
    }
  }
  private PresentationApplet() {
  }

  @Override
  public void deselect() {
    terminateSession();
  }

  @Override
  public void process(APDU apdu) {
    byte[] buffer = apdu.getBuffer();
    if (selectingApplet()) {
      return;
    }
    if (apdu.isSecureMessagingCLA()) {
      ISOException.throwIt(ISO7816.SW_SECURE_MESSAGING_NOT_SUPPORTED);
    }
    SEProvider.assertApdu(apdu);
    // process commands to the applet
    if (apdu.isISOInterindustryCLA()) {
      switch (buffer[ISO7816.OFFSET_INS]) {
        case INS_ENVELOPE:
          processEnvelope(apdu);
          break;
        case INS_GET_RESPONSE:
          processGetResponse(apdu, false);
          break;
        default:
          ISOException.throwIt(ISO7816.SW_INS_NOT_SUPPORTED);
      }
    }
  }

  // Reset the buffer once the response is sent or error happens
  private void resetBuffer() {
    Util.arrayFillNonAtomic(mContext.mBuffer, (short) 0, (short) mContext.mBuffer.length, (byte) 0);
  }

  // Process the envelope
  // 1. Receive all the data. This can consist on multiple APDUs. Internal buffer must be big
  // enough.
  // 2. Create Session and establish the session specific crypto material. Alternatively, use
  // the existing session if available.
  // 3. Decrypt the enveloped data.
  // 4. process the device request.
  private static void processEnvelope(APDU apdu) {
    // receive all the bytes into internal mBuffer
    if (receiveBytes(apdu)) {
      return;
    }
    // extract the request from 0x53 tag
    short bufIndex = extractRequest(mContext.mBuffer, (short) mContext.mBuffer.length, mRetVal);
    short bufLen = mRetVal[0];
    com.android.javacard.mdl.jcardsim.SEProvider.print(mContext.mBuffer, bufIndex, bufLen);
    short requestType = Session.isSessionInitialized() ? MdlSpecifications.IND_SESSION_DATA :
        MdlSpecifications.IND_SESSION_ESTABLISHMENT;
    short offset = MdlSpecifications.decodeStructure(MdlSpecifications.getStructure(requestType),
        mStructure, mContext.mBuffer, bufIndex, bufLen);
    if (offset < 0 || offset != (short) (bufIndex + bufLen)) {
      ISOException.throwIt(ISO7816.SW_DATA_INVALID);
    }
    // Extract the cbor binary string
    mDecoder.init(mContext.mBuffer, mStructure[2], mStructure[3]);
    short encDataLen = mDecoder.readMajorType(CBORBase.TYPE_BYTE_STRING);
    short encDataStart = mDecoder.getCurrentOffset();

    // If this is the session establishment
    if (requestType == MdlSpecifications.IND_SESSION_ESTABLISHMENT) {
      // then both the reader's key and encrypted device request must be present
      if (mStructure[0] == INVALID_VALUE || encDataStart == INVALID_VALUE) {
        ISOException.throwIt(ISO7816.SW_WRONG_DATA);
      }
      // Copy the encoded reader key into class variable.
      Util.arrayCopyNonAtomic(mContext.mBuffer, mStructure[0], Session.mReaderEncodedKeyBytes,
          (short) 2, mStructure[1]);
      Util.setShort(Session.mReaderEncodedKeyBytes, (short) 0, mStructure[1]);
      // creates session transcript and mCryptoKey
      Session.computeSessionDataAndSecrets();
    } else {
      // else the reader's key must be absent and either encrypted data or status must be present
      // - but both cannot be absent or present at the same time.
      if ((mStructure[0] == INVALID_VALUE) == (
          mStructure[2] == INVALID_VALUE)) {
        ISOException.throwIt(ISO7816.SW_WRONG_DATA);
      }
    }

    // Session is established, so decrypt and process the data. Then send the response
    if (encDataStart != INVALID_VALUE) {
      // Decrypt the data
      System.out.println("Device Side Cipher text with size " + encDataLen + " bytes:");
      SEProvider.print(mContext.mBuffer, encDataStart, encDataLen);
      encDataLen = Session.encryptDecryptData(mContext.mBuffer, encDataStart, encDataLen,
          Session.mReaderKey, mMsgCounter[READER_MSG_COUNTER], false, mRetVal, false);
      System.out.println("Device Side Plain text with size " + encDataLen + " bytes:");
      SEProvider.print(mContext.mBuffer, encDataStart, encDataLen);
      mMsgCounter[READER_MSG_COUNTER]++;

      // Process the device request.
      mContext.mDocumentsCount[0] = (byte) processDeviceRequest(
          mContext.mBuffer, encDataStart, encDataLen, mContext.mDocumentRequests);
      //If there are no requests.
      if(mContext.mDocumentsCount[0] <= 0){
        sendSuccessResponseWithoutDocs(apdu);
      }else {
        // Send the response.
        processGetResponse(apdu, true);
      }
    } else if (mStructure[1] == (short) 0x20 ||
        mStructure[1] == (short) 0x10 ||
        mStructure[1] == (short) 0x11) {
      // error status is present, so terminate the session,.
      terminateSession();
    } else { // invalid data is present.
      ISOException.throwIt(ISO7816.SW_DATA_INVALID);
    }
  }

  /**
   * This method creates Device response with only version and status elements. Status will be
   * success and documents array will be empty.
   * @param apdu
   */
  private static void sendSuccessResponseWithoutDocs(APDU apdu) {
    if (mContext.mChunkSize[0] != 0) {
      ISOException.throwIt(ISO7816.SW_CONDITIONS_NOT_SATISFIED);
    }
    byte[] buf = apdu.getBuffer();
    short le = apdu.setOutgoing();
    // encode the response
    mEncoder.init(mScratchPad, (short)0, (short) mScratchPad.length);
    short len = encodeDeviceResponseStartSuccess(mEncoder,(byte)0);

    // create the headers in apdu buffer. Note: the response length needs to include GCM Auth tag
    short index = addEnvAndSessionHeaders(buf, (short)0,le,
        (short) (len + SEProvider.AES_GCM_TAG_LENGTH));

    // Copy the encoded device response to the apdu buffer
    Util.arrayCopyNonAtomic(mScratchPad, (short)0, buf, index, le);

    //Now encrypt the device response using SKDeviceSecret and DeviceCounter
    System.out.println("Device Side Plain text with size " + index + " bytes:");
    SEProvider.print(buf, (short)0, index);
    short encLen = Session.encryptDecryptData(buf, index, len,
        Session.mDeviceKey, mMsgCounter[DEVICE_MSG_COUNTER],
        true, mRetVal, false);
    if(encLen != (short) (len +SEProvider.AES_GCM_TAG_LENGTH)){
      ISOException.throwIt(ISO7816.SW_UNKNOWN);
    }
    System.out.println("Device Side Cipher text with size " + encLen + " bytes:");
    SEProvider.print(buf, (short) 0, (short) (index + encLen));
    mMsgCounter[DEVICE_MSG_COUNTER]++;
    sendBytes(apdu, (short)0, (short) (index + encLen), ISO7816.SW_NO_ERROR);
  }

  private static void addDocumentErrorsToResponse() {
    //TODO use mDeviceRequest to generate documentError in mBuffer. Send that first followed by
    // document
  }

  private static boolean processReaderAuth(byte[] buf, short itemsStart, short itemsLen,
      short readerAuth, short readerAuthLen) {
    //TODO complete this
    return true;
  }

  // Process Device Request
  //
  // 1. create the data structure for DocumentRequest data structure for the doc requests and Items
  // Requests. Device request consists of three layer of structures:
  // Device request-> docRequest -> ItemsRequest
  // And Items Request consists of Doc Type, etc. This method just creates an index of all the
  // namespaces and corresponding data elements requested.
  // 2. Perform reader auth for each document request.
  // 3. Assemble response. Add Issuer signed, issuer auth device signed and device auth
  // TODO Currently this method does not process intentToRetain flag and just ignores it.
  private static short processDeviceRequest(
      byte[] buf, short deviceRequestStart, short deviceRequestLen,
      Object[] documentRequests) {

    // First decode the top level
    short[] str = MdlSpecifications.getStructure(MdlSpecifications.KEY_DEVICE_REQUEST);
    MdlSpecifications.decodeStructure(str, mStructure, buf, deviceRequestStart, deviceRequestLen);

    //Validate device request version.
    //TODO verify whether device request version is valid or not.
    // it should be "1.0" and less then the version of device engagement.
    // Currently we only check for "1.0".
    if (Util.arrayCompare(
        buf, mStructure[0], MdlSpecifications.DEVICE_REQ_VERSION, (short) 0, mStructure[1]) != 0) {
      ISOException.throwIt(ISO7816.SW_DATA_INVALID);
    }

    // Now decode the array of doc requests
    mDecoder.init(buf, mStructure[2], mStructure[3]);
    short docReqLen = mDecoder.readMajorType(CBORBase.TYPE_ARRAY);

    // Then read doc requests one by one to create Document.
    short current = mDecoder.getCurrentOffset();
    for (short i = 0; i < docReqLen; i++) {
      short next = mDecoder.skipEntry();
      DocumentRequest docRequest = (DocumentRequest) documentRequests[i];
      docRequest.reset();

      // Decode a doc request
      str = MdlSpecifications.getStructure(MdlSpecifications.KEY_DOC_REQUESTS);
      current = MdlSpecifications.decodeStructure(str, mStructure, buf, current,
          (short) (next - current));
      if (current != next) {
        ISOException.throwIt(ISO7816.SW_DATA_INVALID);
      }
      short itemsStart = mStructure[0];
      short itemsLen = mStructure[1];
      short readerAuthStart = mStructure[2];
      short readerAuthLen = mStructure[3];
      if (itemsStart == INVALID_VALUE || readerAuthStart == INVALID_VALUE) {
        ISOException.throwIt(ISO7816.SW_DATA_INVALID);
      }

      // Now process Items Request
      if (!processItemsRequest(buf, itemsStart, itemsLen, readerAuthStart, readerAuthLen,
          docRequest)) {
        docRequest.setError();
        docRequest.setErrorCode(MdlSpecifications.MDL_ERR_NOT_FOUND);
      }
    }
    return docReqLen;
  }

  private static boolean processItemsRequest(byte[] buf, short start, short len,
      short readerAuthStart, short readerAuthLen,
      DocumentRequest req) {

    //Now get the doc type out of the items
    mDecoder.init(buf, start, len);
    if (mDecoder.readMajorType(CBORBase.TYPE_TAG) !=
        MdlSpecifications.CBOR_SEMANTIC_TAG_ENCODED_CBOR) {
      ISOException.throwIt(ISO7816.SW_DATA_INVALID);
    }
    short itemsLen = mDecoder.readMajorType(CBORBase.TYPE_BYTE_STRING);
    short itemsStart = mDecoder.getCurrentOffset();

    // read items request within this doc request to extract the doc type.
    short[] str = MdlSpecifications.getStructure(MdlSpecifications.KEY_ITEMS_REQUEST);
    MdlSpecifications.decodeStructure(str, mStructure, mContext.mBuffer, itemsStart, itemsLen);
    short docTypeStart = mStructure[0];
    short docTypeLen = mStructure[1];
    short nameSpacesStart = mStructure[2];
    short nameSpacesLen = mStructure[3];
    SEProvider.print(buf, itemsStart, itemsLen);
    SEProvider.print(buf, docTypeStart, docTypeLen);
    SEProvider.print(buf, nameSpacesStart, nameSpacesLen);
    //TODO currently just storing the requestInfo and it is not used.
    short requestInfo = mStructure[4];
    short requestInfoLen = mStructure[5];
    // document with the desired doc type must be present and if it requires reader
    // authentication then reader authentication must be successful.
    if (docTypeStart == (short) 0 || nameSpacesStart == (short) 0) {
      return false;
    }
    // Now get the document.
    MdocPresentationPkg doc = PresentationPkgStore.instance().findPackage(buf, docTypeStart,
        docTypeLen);
    if (doc == null ||
        (doc.isReaderAuthRequired() &&
            !processReaderAuth(buf, start, len, readerAuthStart, readerAuthLen))) {
      return false;
    }
    // Now initialise the document request which will parse the name spaces and create internal
    // mapping to stored data.
    return req.init(doc, mStructure, buf, nameSpacesStart, nameSpacesLen,
        mScratchPad, (short) 0, (short) mScratchPad.length);
    //TODO match individual items requested by the doc request with that in the document. If
    // not available then error must be returned for those items or the entire doc request.
  }
  /*
  private static boolean processItemsRequest(byte[] buf, short itemsStart, short itemsLen,
      short readerAuthStart, short readerAuthLen, DocumentRequest req) {
    //Now get the doc type out of the items
    itemsStart = readTaggedCborByteString(buf, itemsStart, itemsLen, mRetVal);
    itemsLen = mRetVal[0];
    // read items request within this doc request to extract the doc type.
    short[] str = MdlSpecifications.getStructure(MdlSpecifications.KEY_ITEMS_REQUEST);
    MdlSpecifications.decodeStructure(str, mStructure, Context.mBuffer, itemsStart, itemsLen);
    short docTypeStart = mStructure[0];
    short docTypeLen = mStructure[1];
    short nameSpacesStart = mStructure[2];
    short nameSpacesLen = mStructure[3];
    short requestInfo = mStructure[4];
    short requestInfoLen = mStructure[5];
    // document with the desired doc type must be present and if it requires reader
    // authentication then reader authentication must be successful.
    if (docTypeStart == (short) 0 || nameSpacesStart == (short) 0) {
      return false;
    }
    // Now get the document.
    MdocPresentationPkg doc = PresentationPkgStore.instance().findPackage(buf, docTypeStart,
        docTypeLen);
    if(doc == null ||
        (doc.isReaderAuthRequired() &&
            !processReaderAuth(buf,itemsStart, itemsLen, readerAuthStart, readerAuthLen))) {
      return false;
    }
    // Now initialise the document request.
    return req.init(doc, mStructure, buf, nameSpacesStart, nameSpacesLen);
    //TODO match individual items requested by the doc request with that in the document. If
    // not available then error must be returned for those items or the entire doc request.
    }
*/
    /*
    // TODO cache the data items such as signature which can be then used in handle device request.
    deviceRequestLen = mRetVal[0];
    short signStart = retVal[1];
    short signLen = retVal[2];
    authenticateReader(buffer, deviceRequestStart, deviceRequestLen, signStart,signLen, retVal);
    // handle the device request and this returns the start and length of device response and MSO
    // in retVal[0] and retVal[1]
    handleDeviceRequest(buffer, deviceRequestStart, deviceRequestLen, retVal);

     */


  private static void terminateSession() {
    reset();
  }

  private static short getHeaderLength(short len) {
    byte headerLen = 4;
    if (len < 128) {
      headerLen = 2;
    } else if (len < 256) {
      headerLen = 3;
    }
    return headerLen;
  }

  private static short encapsulateResponse(byte[] buf, short index, short len) {
    short offset = index;
    short headerLen = getHeaderLength(len);
    index = Util.arrayCopyNonAtomic(buf, index, buf, (short) (index + headerLen), len);
    short ret = (short) (index - offset);
    buf[offset++] = (byte) 0x53;
    if (headerLen == 2) {
      buf[offset] = (byte) len;
    } else if (headerLen == 3) {
      buf[offset++] = (byte) 0x81;
      buf[offset] = (byte) len;
    } else {
      buf[offset++] = (byte) 0x82;
      Util.setShort(buf, offset, len);
    }
    return ret;
  }

  private static boolean receiveBytes(APDU apdu) {
    byte[] buf = apdu.getBuffer();
    boolean moreChunksToCome = false;
    if (buf[ISO7816.CLA_ISO7816] == 0x10) {
      moreChunksToCome = true;
    } else if (buf[ISO7816.CLA_ISO7816] != 0x00) {
      ISOException.throwIt(ISO7816.SW_RECORD_NOT_FOUND);
    }
    apdu.setIncomingAndReceive();
    short len = apdu.getIncomingLength();
    if (len == 0) {
      ISOException.throwIt(ISO7816.SW_WRONG_LENGTH);
    }

    if ((short) (len + mContext.mBufWriteIndex[0]) > mContext.mBuffer.length) {
      ISOException.throwIt(ISO7816.SW_RECORD_NOT_FOUND);
    }
    Util.arrayCopyNonAtomic(buf,
        buf[ISO7816.OFFSET_LC] != 0 ? ISO7816.OFFSET_CDATA : ISO7816.OFFSET_EXT_CDATA,
       mContext.mBuffer, mContext.mBufWriteIndex[0], len);
    mContext.mBufWriteIndex[0] += len;
    return moreChunksToCome;
  }

  private static short extractRequest(byte[] buffer, short bufLen, short[] ret) {
    // extract the tag 0x53
    short tag = (short) (buffer[0] & 0xFF);
    short tagLen = (short) (buffer[1] & 0xff);
    short offset = 2;
    if (tag != (byte) 0x53) {
      ISOException.throwIt(ISO7816.SW_RECORD_NOT_FOUND);
    }
    if (tagLen == (short) 0x0081) {
      tagLen = (short) (buffer[2] & 0xff);
      offset = 3;
    } else if (tagLen == (short) 0x0082) {
      tagLen = Util.getShort(buffer, (short) 2);
      offset = 4;
    } else if (tagLen == (short) 0x0080 || tagLen > 0x0082) {
      ISOException.throwIt(ISO7816.SW_RECORD_NOT_FOUND);
    }
    if ((short) (tagLen + offset) > bufLen) {
      ISOException.throwIt(ISO7816.SW_RECORD_NOT_FOUND);
    }
    SEProvider.print(buffer, offset, tagLen);
    ret[0] = tagLen;
    return offset;
  }

  /**
   * SessionData = {
   * ? "data" : bstr ; Encrypted mdoc response or mdoc request
   * ? "status" : uint ; Status code
   * }
   * We only add start of "data" in this method.
   */

  /**
   * Adds status. Status = err must be less the 0x18.
   */
  static short pushSessionDataHeaderError(byte[] buf, short offset, short len, byte err) {
    if (err >= CBORBase.ENCODED_ONE_BYTE) {
      ISOException.throwIt(ISO7816.SW_UNKNOWN);
    }
    offset -= (short) (MdlSpecifications.status.length - 2);
    mEncoder.init(buf, offset, len);
    //add map
    mEncoder.startMap((short) 1);
    //add "status" key
    mEncoder.encodeRawData(MdlSpecifications.status, (short) 0,
        (short) (MdlSpecifications.session_data.length));
    // add cbor byte string
    mEncoder.encodeUInt8(err);
    return offset;
  }


  /**
   * DeviceResponse = { "version" : tstr, ; Version of the DeviceResponse structure ? "documents" :
   * [+Document], ; Returned documents ? "documentErrors": [+DocumentError]; For unreturned
   * documents, optional error codes "status" : uint ; Status code } Document = { "docType" :
   * DocType, ; Document type returned "issuerSigned" : IssuerSigned, ; Returned data elements
   * signed by the issuer "deviceSigned" : DeviceSigned, ; Returned data elements signed by the mdoc
   * ? "errors" : Errors } DocumentError = { DocType => ErrorCode ; Error codes for unreturned
   * documents } IssuerSigned = { ? "nameSpaces" : IssuerNameSpaces, ; Returned data elements
   * "issuerAuth" : IssuerAuth ; Contains the mobile security object (MSO) ; for issuer data
   * authentication } IssuerNameSpaces = { ; Returned data elements for each namespace + NameSpace
   * => [ + IssuerSignedItemBytes ] } IssuerSignedItemBytes = #6.24(bstr .cbor IssuerSignedItem)
   * IssuerSignedItem = { "digestID" : uint, ; Digest ID for issuer data authentication "random" :
   * bstr, ; Random value for issuer data authentication "elementIdentifier" :
   * DataElementIdentifier, ; Data element identifier "elementValue" : DataElementValue ; Data
   * element value } DeviceSigned = { "nameSpaces" : DeviceNameSpacesBytes, ; Returned data elements
   * "deviceAuth" : DeviceAuth ; Contains the device authentication ; for mdoc authentication }
   * DeviceNameSpacesBytes = #6.24(bstr .cbor DeviceNameSpaces) DeviceNameSpaces = { * NameSpace =>
   * DeviceSignedItems ; Returned data elements for each namespace } DeviceSignedItems = { +
   * DataElementIdentifier => DataElementValue ; Returned data element identifier and value }
   * DeviceAuth = { ; Either signature or MAC for mdoc authentication "deviceSignature" :
   * DeviceSignature // ; "//" means or "deviceMac" : DeviceMac } Where DeviceMac is COSEMac0 -
   * Array of 4 with protected content {alg=5}, no un protected content and payload followed by mac
   * tag. [ << {1: 5} >>, {}, null, h'
   * E99521A85AD7891B806A07F8B5388A332D92C189A7BF293EE1F543405AE6824D' ]
   * <p>
   * Errors = { + NameSpace => ErrorItems ; Error codes for each namespace } ErrorItems = { +
   * DataElementIdentifier => ErrorCode ; Error code per data element } ErrorCode = int ; Error
   * code
   * TODO this method only returns one document currently. In future this needs to expanded to
   *  return multiple documents, Also this method currently does not send any errors.
   */

  private static short startDeviceResponse() {
    mEncoder.init(mContext.mBuffer,mContext.mBufWriteIndex[0], (short)mContext.mBuffer.length);

    // Map of 3 because we do not return error. If there is no document to return then we will
    // have array of zero length.
    mEncoder.startMap((short) 3);

    // version" : "i.0"
    mEncoder.encodeRawData(MdlSpecifications.version, (short) 0,
        (short) MdlSpecifications.version.length);
    mEncoder.encodeRawData(MdlSpecifications.DEVICE_REQ_VERSION, (short) 0,
        (short) MdlSpecifications.DEVICE_REQ_VERSION.length);

    // "status" : 0 - always ok
    mEncoder.encodeRawData(MdlSpecifications.status, (short) 0,
        (short) MdlSpecifications.status.length);
    mEncoder.encodeUInt8((byte) 0);

    // Now we are only going to handle one document which we know is mdl doc type. So just hard
    // code it.TODO in future this part needs to be changed to handle multiple doc types.
    // "documents" : [+Document]
    mEncoder.encodeRawData(MdlSpecifications.documents, (short) 0,
        (short) MdlSpecifications.documents.length);
    mEncoder.startArray(mContext.mDocumentsCount[0]);
    // Document
    mEncoder.startMap((short) 3);
    // "docType" : DocType
    mEncoder.encodeRawData(MdlSpecifications.docType, (short) 0,
        (short) MdlSpecifications.docType.length);
    mEncoder.encodeRawData(MdlSpecifications.mdlDocType, (short) 0,
        (short) MdlSpecifications.mdlDocType.length);
    // "deviceSigned" : DeviceSigned
    mEncoder.encodeRawData(MdlSpecifications.deviceSigned, (short) 0,
        (short) MdlSpecifications.deviceSigned.length);
    // DeviceSigned
    mEncoder.startMap((short) 2);
    // nameSpaces" : DeviceNameSpacesBytes - empty structure
    mEncoder.encodeRawData(MdlSpecifications.nameSpaces, (short) 0,
        (short) MdlSpecifications.nameSpaces.length);
    mEncoder.encodeUInt8((byte) MdlSpecifications.CBOR_SEMANTIC_TAG_ENCODED_CBOR);
    mEncoder.startByteString((short) 0); // empty
    //"deviceAuth" : DeviceAuth
    mEncoder.encodeRawData(MdlSpecifications.deviceAuth, (short) 0,
        (short) MdlSpecifications.deviceAuth.length);
    //DeviceAuth
    mEncoder.startMap((byte) 1);
    //"deviceMac" : DeviceMac - DeviceMac is Cose structure
    mEncoder.encodeRawData(MdlSpecifications.deviceMac, (short) 0,
        (short) MdlSpecifications.deviceMac.length);
    // DeviceMac
    mEncoder.startArray((short) 4);
    // Protected content which is map with one key value pair
    // Protected
    mEncoder.startByteString((short) 3);
    mEncoder.startMap((short) 1);
    mEncoder.encodeUInt8((byte) MdlSpecifications.COSE_LABEL_ALG);
    mEncoder.encodeUInt8((byte) MdlSpecifications.COSE_ALG_HMAC_256_256);
    // Unprotected is empty
    mEncoder.startMap((short) 0);
    // payload is null
    mEncoder.writeRawByte((byte) MdlSpecifications.CBOR_NIL);
    // Mac tag
    byte[] macTag = ((DocumentRequest)mContext.mDocumentRequests[0]).getDeviceAuthMacTag();
    mEncoder.encodeRawData(macTag, (short) 0, (short) macTag.length);
    short len = (short) (mEncoder.getCurrentOffset() -mContext.mBufWriteIndex[0]);
   mContext.mRemainingBytes[0] = len;
   mContext.mBufWriteIndex[0] = mEncoder.getCurrentOffset();
    // Only thing remaining is issuer Signed so add its length
    return len;
  }


  private static short calculateResponseLength(){
    byte[] buf = new byte[10000];
    mEncoder.init(buf, (short)0, (short) buf.length);
    mCalculator.initialize((short)0, MAX_RESPONSE_SIZE);
   mContext.mIncrementalResponseState[Context.CURRENT_STATE] =mContext.RESP_START;
   mContext.mIncrementalResponseState[Context.CURRENT_STATE] =mContext.RESP_START;
   mContext.mIncrementalResponseState[Context.CURRENT_NAMESPACE] = 0;
   mContext.mIncrementalResponseState[Context.CURRENT_ELEMENT] = 0;
   mContext.mIncrementalResponseState[Context.CURRENT_DATA_PTR_START] = 0;
   mContext.mIncrementalResponseState[Context.CURRENT_DATA_PTR_END] = 0;
    while(mContext.mIncrementalResponseState[Context.CURRENT_STATE] !=mContext.RESP_IDLE){
      encodeResponse(mEncoder);
      SEProvider.print(buf, (short)0, mEncoder.getCurrentOffset());
    }
    return mEncoder.getCurrentOffset();
  }
/*
  private static short calculateResponseLength() {
    mCalculator.initialize((short)0, MAX_BUF_SIZE);
    for (short i = 0; i < Context.mReqCount[0]; i++) {
      DocumentRequest req = (DocumentRequest) Context.mDocumentRequests[i];
      mEncoder.startMap((short) 3);
      len += encodeDocumentStart(mEncoder, req);
      mEncoder.reset();
      len += encodeDeviceSigned(mEncoder, req);
      short tmp = 0;
      do {
        len += tmp;
        mEncoder.reset();
        tmp = encodeIssuerSignedIncrementally(mEncoder, req, true);
      } while (tmp != 0);
    }
    return len;
  }
*/
  /**
   * DeviceResponse = {
   * "version" : tstr, ; Version of the DeviceResponse structure
   * ? "documents" : [+Document], ; Returned documents
   * ? "documentErrors": [+DocumentError]; For unreturned documents, optional error codes
   * "status" : uint ; Status code
   * }
   * This method encodes version and status which is always success.
   */
  private static short encodeDeviceResponseStartSuccess(CBOREncoder encoder, byte reqCount) {
    // Map of 3 because we do not return error. Ot of three elements two are encoded here and the
    // third i.e. array of documents is encoded in separate method which will be called from
    // encodeResponse method.
    short start = encoder.getCurrentOffset();
    encoder.startMap((short) 3);

    // version" : "i.0"
    encoder.encodeRawData(MdlSpecifications.version, (short) 0,
        (short) MdlSpecifications.version.length);
    encoder.encodeRawData(MdlSpecifications.DEVICE_REQ_VERSION, (short) 0,
        (short) MdlSpecifications.DEVICE_REQ_VERSION.length);
    // "status" : 0 - always ok
    encoder.encodeRawData(MdlSpecifications.status, (short) 0,
        (short) MdlSpecifications.status.length);
    // o - always ok
    encoder.encodeUInt8((byte)0);
    // "documents" : [+Document]
    encoder.encodeRawData(MdlSpecifications.documents, (short) 0,
        (short) MdlSpecifications.documents.length);
    encoder.startArray(reqCount);
    return (short) (encoder.getCurrentOffset() - start);
  }

  /**
   * Document = {
   * "docType" : DocType, ; Document type returned
   * "issuerSigned" : IssuerSigned, ; Returned data elements signed by the issuer
   * "deviceSigned" : DeviceSigned, ; Returned data elements signed by the mdoc
   * ? "errors" : Errors
   * }
   * This encodes start of map and docType.
   */
  private static short encodeDocumentStart(CBOREncoder encoder, DocumentRequest request) {
    short start = encoder.getCurrentOffset();
    // Document
    encoder.startMap((short) 3);
    // "docType" : DocType
    encoder.encodeRawData(MdlSpecifications.docType, (short) 0,
        (short) MdlSpecifications.docType.length);
    short len = request.getDocType(mScratchPad,(short)0);
    encoder.encodeRawData(mScratchPad, (short)0, len);
    return (short) (encoder.getCurrentOffset() - start);
  }

  /**
   * Document = {
   *   ...
   * "deviceSigned" : DeviceSigned, ; Returned data elements signed by the mdoc
   *  ...
   * }
   *"deviceSigned" : DeviceSigned
   *
   * DeviceSigned = {
   * "nameSpaces" : DeviceNameSpacesBytes, ; Returned data elements
   * "deviceAuth" : DeviceAuth ; Contains the device authentication
   * ; for mdoc authentication
   * }
   * DeviceNameSpacesBytes = this is empty i.e. 0 bytes
   * DeviceAuth = {
   * "deviceMac" : DeviceMac
   * }
   * DeviceMac is COSE_Mac0 structure (section 9.1.3.5), where payload is null, ‘external_aad’ is
   * byte string of 0 bytes and alg element in protected header will be “HMAC 256/256” i.e. 1.
   * The mac tag will be calculated in request.
   *
   * This method encodes device signed key value pair. Note we don't divide this because we
   * calculate the entire during querying stage.
   */
  private static short encodeDeviceSigned(CBOREncoder encoder, DocumentRequest request) {
    short start = encoder.getCurrentOffset();
    // "deviceSigned" : DeviceSigned
    encoder.encodeRawData(MdlSpecifications.deviceSigned, (short) 0,
        (short) MdlSpecifications.deviceSigned.length);
    // DeviceSigned
    encoder.startMap((short) 2);
    // nameSpaces" : DeviceNameSpacesBytes - empty structure
    encoder.encodeRawData(MdlSpecifications.nameSpaces, (short) 0,
        (short) MdlSpecifications.nameSpaces.length);
    encoder.encodeTag((byte) MdlSpecifications.CBOR_SEMANTIC_TAG_ENCODED_CBOR);
    encoder.startByteString((short) 0); // empty
    //"deviceAuth" : DeviceAuth
    encoder.encodeRawData(MdlSpecifications.deviceAuth, (short) 0,
        (short) MdlSpecifications.deviceAuth.length);
    //DeviceAuth
    encoder.startMap((byte) 1);
    //"deviceMac" : DeviceMac - DeviceMac is Cose structure
    encoder.encodeRawData(MdlSpecifications.deviceMac, (short) 0,
        (short) MdlSpecifications.deviceMac.length);
    // DeviceMac - array of 4.
    encoder.startArray((short) 4);
    // 1. Protected content which is map with one key value pair
    // Protected
    encoder.startByteString((short) 3);
    encoder.startMap((short) 1);
    encoder.encodeUInt8((byte) MdlSpecifications.COSE_LABEL_ALG);
    encoder.encodeUInt8((byte) MdlSpecifications.COSE_ALG_HMAC_256_256);
    // 2. Unprotected is empty
    encoder.startMap((short) 0);
    // 3. payload is null
    encoder.writeRawByte((byte) MdlSpecifications.CBOR_NIL);
    // 4. Mac tag - always 32 bytes long
    byte[] macTag = request.getDeviceAuthMacTag();
    encoder.encodeRawData(macTag, (short) 0, (short) macTag.length);
    return (short) (encoder.getCurrentOffset() - start);
  }

  private static short calculateDocumentResponseLength(DocumentRequest request) {
    mEncoder.init(mScratchPad, (short) 0, (short) mScratchPad.length);
    // "deviceSigned" : DeviceSigned
    mEncoder.encodeRawData(MdlSpecifications.deviceSigned, (short) 0,
        (short) MdlSpecifications.deviceSigned.length);
    // DeviceSigned
    mEncoder.startMap((short) 2);
    // nameSpaces" : DeviceNameSpacesBytes - empty structure
    mEncoder.encodeRawData(MdlSpecifications.nameSpaces, (short) 0,
        (short) MdlSpecifications.nameSpaces.length);
    mEncoder.encodeUInt8((byte) MdlSpecifications.CBOR_SEMANTIC_TAG_ENCODED_CBOR);
    mEncoder.startByteString((short) 0); // empty
    //"deviceAuth" : DeviceAuth
    mEncoder.encodeRawData(MdlSpecifications.deviceAuth, (short) 0,
        (short) MdlSpecifications.deviceAuth.length);
    //DeviceAuth
    mEncoder.startMap((byte) 1);
    //"deviceMac" : DeviceMac - DeviceMac is Cose structure
    mEncoder.encodeRawData(MdlSpecifications.deviceMac, (short) 0,
        (short) MdlSpecifications.deviceMac.length);
    // DeviceMac
    mEncoder.startArray((short) 4);
    // Protected content which is map with one key value pair
    // Protected
    mEncoder.startByteString((short) 3);
    mEncoder.startMap((short) 1);
    mEncoder.encodeUInt8((byte) MdlSpecifications.COSE_LABEL_ALG);
    mEncoder.encodeUInt8((byte) MdlSpecifications.COSE_ALG_HMAC_256_256);
    // Unprotected is empty
    mEncoder.startMap((short) 0);
    // payload is null
    mEncoder.writeRawByte((byte) MdlSpecifications.CBOR_NIL);
    // Mac tag
    byte[] macTag = ((DocumentRequest)mContext.mDocumentRequests[0]).getDeviceAuthMacTag();
    mEncoder.encodeRawData(macTag, (short) 0, (short) macTag.length);
    // "issuerSigned":IssuerSigned
    mEncoder.encodeRawData(MdlSpecifications.issuerSigned, (short) 0,
        (short) MdlSpecifications.issuerSigned.length);
    // "issuerAuth":IssuerAuth
    mEncoder.encodeRawData(MdlSpecifications.issuerAuth, (short) 0,
        (short) MdlSpecifications.issuerAuth.length);
    short len = mEncoder.getCurrentOffset();
    MdocPresentationPkg doc = request.getDocument();
    len += doc.getIssuerAuthLength(); // This is already encoded as COSESign1. TODO check this out
    mEncoder.reset();
    mEncoder.encodeRawData(MdlSpecifications.nameSpaces,
        (short) 0, (short) MdlSpecifications.nameSpaces.length);
    short[] nsTable = request.getNsTable();
    short nsTableSize =
        (short) (request.getNsTableEnd() / MdocPresentationPkg.NS_TABLE_ROW_SIZE);
    short[] elemTable = request.getElemTable();
    short elemTableSize =
        (short) (request.getElemTableEnd() / MdocPresentationPkg.ELEM_TABLE_ROW_SIZE);
    MdocPresentationPkg pkg = request.getDocument();
    mEncoder.startMap(nsTableSize);
    for (byte i = 0; i < nsTableSize; i += MdocPresentationPkg.NS_TABLE_ROW_SIZE) {
      short nsId = nsTable[(short) (i + MdocPresentationPkg.NS_KEY_ID_OFFSET)];
      byte[] nsStr = MdlSpecifications.getDocNameSpaceString(nsId);
      mEncoder.encodeRawData(nsStr, (short) 0, (short) nsStr.length);
      mEncoder.startArray(elemTableSize);
      len += mEncoder.getCurrentOffset();
      for (byte j = 0; j < elemTableSize; j += MdocPresentationPkg.ELEM_TABLE_ROW_SIZE) {
        len += elemTable[(short) (j + MdocPresentationPkg.ELEM_VALUE_LENGTH_OFFSET)];
      }
      mEncoder.reset();
    }
    return len;
  }

  private static short calculateIssuerSigned() {
    mEncoder.init(mScratchPad, (short) 0, (short) mScratchPad.length);
    // "issuerSigned":IssuerSigned
    mEncoder.encodeRawData(MdlSpecifications.issuerSigned, (short) 0,
        (short) MdlSpecifications.issuerSigned.length);
    // "issuerAuth":IssuerAuth
    mEncoder.encodeRawData(MdlSpecifications.issuerAuth, (short) 0,
        (short) MdlSpecifications.issuerAuth.length);
    short dataLen = mEncoder.getCurrentOffset();
    mEncoder.reset();
    // Read the issuer auth ptr from the presentation package
    DocumentRequest request = (DocumentRequest)mContext.mDocumentRequests[0];
    MdocPresentationPkg doc = request.getDocument();
    dataLen += doc.getIssuerAuthLength();
    mEncoder.encodeRawData(MdlSpecifications.nameSpaces,
        (short) 0, (short) MdlSpecifications.nameSpaces.length);
    short[] nsTable = request.getNsTable();
    short nsTableSize =
        (short) (request.getNsTableEnd() / MdocPresentationPkg.NS_TABLE_ROW_SIZE);
    short[] elemTable = request.getElemTable();
    short elemTableSize =
        (short) (request.getElemTableEnd() / MdocPresentationPkg.ELEM_TABLE_ROW_SIZE);
    MdocPresentationPkg pkg = request.getDocument();
    mEncoder.startMap(nsTableSize);
    for (byte i = 0; i < nsTableSize; i += MdocPresentationPkg.NS_TABLE_ROW_SIZE) {
      short nsId = nsTable[(short) (i + MdocPresentationPkg.NS_KEY_ID_OFFSET)];
      byte[] nsStr = MdlSpecifications.getDocNameSpaceString(nsId);
      mEncoder.encodeRawData(nsStr, (short) 0, (short) nsStr.length);
      mEncoder.startArray(elemTableSize);
      dataLen += mEncoder.getCurrentOffset();
      for (byte j = 0; j < elemTableSize; j += MdocPresentationPkg.ELEM_TABLE_ROW_SIZE) {
        dataLen += elemTable[(short) (j + MdocPresentationPkg.ELEM_VALUE_LENGTH_OFFSET)];
      }
      mEncoder.reset();
    }
    return dataLen;
  }
/*
  private static short processNextChunk() {
    mEncoder.init(Context.mBuffer, Context.mBufWriteIndex[0], (short) Context.mBuffer.length);
    // Now at this stage only issuer signed data remains. In this element we will not copy actual
    // data but pointers to data. But we will create total length counter also.
    // "issuerSigned":IssuerSigned
    //IssuerSigned has two elements - namespaces and issuerAuth. We will first put issuerAuth and
    // then namespaces.
    // "issuerAuth":IssuerAuth
    mEncoder.encodeRawData(MdlSpecifications.issuerAuth, (short) 0,
        (short) MdlSpecifications.issuerAuth.length);
    // IssuerAuth
    short totalLen = mEncoder.getCurrentOffset();
    // Read the issuer auth ptr from the presentation package
    MdocPresentationPkg doc = ((DocumentRequest) Context.mDocumentRequests[0]).getDocument();
    short authStart = doc.getmIssuerAuthStart();
    short authLen = doc.getmIssuerAuthLength();
    // Create a placeholder tuple of shorts pointing to the actual data,
    // which can be used during rendering
    mEncoder.writeRawShort(authStart);
    mEncoder.writeRawShort(authLen);
    totalLen += authLen;
    // "namespaces": {NameSpace => [ItemBytes]}
    mEncoder.encodeRawData(MdlSpecifications.nameSpaces, (short) 0,
        (short) MdlSpecifications.nameSpaces.length);
    short nsCount =
        (short) (((DocumentRequest) Context.mDocumentRequests[0]).getNsTableEnd() /
            MdocPresentationPkg.NS_TABLE_ROW_SIZE);
    //NameSpace
    // Currently we only support one name space so hard code it
    if (nsCount > 0) {
      mEncoder.startMap(nsCount);
      mEncoder.encodeRawData(MdlSpecifications.mdlNameSpace, (short) 0,
          (short) MdlSpecifications.mdlNameSpace.length);
      short elementsCount =
          (short) (((DocumentRequest) Context.mDocumentRequests[0]).getElemTableEnd() /
              MdocPresentationPkg.ELEM_TABLE_ROW_SIZE);
      if (elementsCount > 0) {
        mEncoder.startArray(elementsCount);
        Context.mIncrementalResponseState[0] = Context.RESP_ISSUER_NS;
        Context.mIncrementalResponseState[1] = (byte) 0;
        Context.mDeviceRespDocument[Context.CURRENT_NAMESPACE] = 0;
        Context.mDeviceRespDocument[Context.CURRENT_ELEMENT] = 0;
        Context.mDeviceRespDocument[Context.CURRENT_DATA_PTR] = 0;
        startDeviceResponse();
      } else {
        mEncoder.startArray((short) 0);
      }
    } else {
      mEncoder.startMap((short) 0);
    }
    return 0;
  }

  private static void writeBytes(CBOREncoder enc, byte[] fromBuffer, short index, short len) {
    short start = enc.getCurrentOffset();
    short remain = (short) (enc.getBufferLength() - start);

  }


  private static short encodeIssuerSignedIncrementally(CBOREncoder encoder, boolean justCalculate) {
    short start = encoder.getCurrentOffset();
    short remainBuf = (short) (encoder.getBufferLength() - start);
    switch (Context.mIncrementalResponseState[0]) {
      case Context.RESP_ISSUER_SIGNED:
        mEncoder.encodeRawData(MdlSpecifications.issuerAuth, (short) 0,
            (short) MdlSpecifications.issuerAuth.length);
        // IssuerAuth
        short totalLen = mEncoder.getCurrentOffset();
        // Read the issuer auth ptr from the presentation package
        MdocPresentationPkg doc = ((DocumentRequest)mContext.mDocumentRequests[
           mContext.mIncrementalResponseState[Context.CURRENT_DOC]]).getDocument();
        short authStart = doc.getmIssuerAuthStart();
        short authLen = doc.getmIssuerAuthLength();
        if (justCalculate) {
          return authLen;
        } else {
         mContext.mIncrementalResponseState[Context.CURRENT_STATE] =mContext.RESP_LEAF;
         mContext.mIncrementalResponseState[Context.NEXT_STATE] =mContext.RESP_ISSUER_NS;
          writeBytes(encoder, doc.getBuffer(), authStart, authLen);
        }
        break;
      case Context.RESP_ISSUER_NS:
        break;
      default:
        ISOException.throwIt(ISO7816.SW_UNKNOWN);
        break;
    }
    return (short) (encoder.getCurrentOffset() - start);
  }
*/

  static short addEnvAndSessionHeaders(byte[] buf, short index, short len,
      short respLength) {
    // add session data header
    // Map of one element
    mEncoder.init(mScratchPad, (short) 0, (short) mScratchPad.length);
    mEncoder.startMap((short) 1);
    //"data" : bstr
    mEncoder.encodeRawData(MdlSpecifications.session_data,
        (short) 0, (short) MdlSpecifications.session_data.length);
    mEncoder.startByteString(respLength);
    respLength += mEncoder.getCurrentOffset();

    // add envelope header
    buf[index++] = (byte) 0x53;
    if (respLength < 128) {
      buf[index++] = (byte) respLength;
    } else if (respLength < 256) {
      buf[index++] = (byte) 0x81;
      buf[index++] = (byte) respLength;
    } else {
      buf[index++] = (byte) 0x82;
      Util.setShort(buf, index, respLength);
      index += 2;
    }
    // Copy the session data header.
    return Util.arrayCopyNonAtomic(mScratchPad, (short) 0, buf, index, mEncoder.getCurrentOffset());
  }

  private static short transferData(byte[] buf, short index, short bufLen){
    // amount of data to be copied from the context buffer
    short len =  (short) (mContext.mBufWriteIndex[0] - mContext.mBufReadIndex[0]);

    // Index points to next empty position in the apdu buffer - starting from zero.
    // So, available space in apdu buffer is (bufLen - index). Now, the buf length will be
    // equal to chunk size as that is the max we can send.
    short availBuf = (short) (bufLen- index);

    // If input data length is more than available apdu buffer space then only send the data
    // length equal to available data length and subtract that from remaining bytes.
    if(len > availBuf){
      len = availBuf;
    }

    // Copy the data from context buffer to apdu buffer.
    Util.arrayCopyNonAtomic( mContext.mBuffer, mContext.mBufReadIndex[0], buf, index, len);
    mContext.mBufReadIndex[0] += len;
    return len;
  }
  private static short encodeData(CBOREncoder encoder){
    short start = encoder.getCurrentOffset();
    // For every doc request. Each document is a root node of the tree.
    while(mContext.mIncrementalResponseState[Context.CURRENT_STATE] != Context.RESP_IDLE) {
      try {
        encodeResponse(mEncoder);
      }catch(ISOException exp){
        // This exception is thrown by encoder when it cannot encode anymore data as it has run
        // out of space.
        if(exp.getReason() == ISO7816.SW_UNKNOWN){
          break;
        }else{
          // Some error happened
          ISOException.throwIt(exp.getReason());
        }
      }
    }
    return (short) (encoder.getCurrentOffset() - start);
  }

  /**
   * This method returns the response to the reader. It checks whether this is the first message in
   * a chain of responses and if so, it handles that differently by calculating entire message
   * length and appending envelope and session headers. Rest of the messages sent incrementally. It
   * sends message les then or equal to chunk size. However, it processes message data greater the
   * chunk size. This is done so that we can take care of element boundaries.
   * <p>
   * For the first message: SessionData = { ? "data" : bstr ; Encrypted mdoc response or mdoc
   * request (includes AES GCM auth tag) ? "status" : uint ; Status code }
   **/
  private static void processGetResponse(APDU apdu, boolean firstMessage) {
    // Start responding and return the requested document.
    // received before we respond, it is also the chunk size.
    byte[] buf = apdu.getBuffer();
    short le = apdu.setOutgoing();
    short index = 0;

    // This is the first message in the chain of responses.
    if (firstMessage) {
      if (mContext.mChunkSize[0] != 0) {
        ISOException.throwIt(ISO7816.SW_CONDITIONS_NOT_SATISFIED);
      }
      // calculate the device response length - this is required because envelope header and
      // session header requires total device response length. This only returns size of data to
      // be encoded. It does not include the Auth tag which will be added to the encrypted
      // device response data.
      mContext.setOutGoing(le, calculateResponseLength(), (short)0);

      // Add the envelope and session data headers and resp length includes the auth tag length
      // which will be concatenated with encrypted response data.
      index = addEnvAndSessionHeaders(buf, (short) 0, mContext.mChunkSize[0],
          (short)(mContext.mRemainingBytes[0] + SEProvider.AES_GCM_TAG_LENGTH));
      SEProvider.print(buf, (short) 0, index);
      //This is the first response message hence initialize for the session encryption.
      Session.beginIncrementalEncryption(mMsgCounter[DEVICE_MSG_COUNTER], mScratchPad, (short) 0,
          (short) mScratchPad.length);
    }
    // Drive the response state machine, which sends the response to individual document requests
    // received in device request one by one - incrementally i.e. in chunks of size = le.
    short len = 0;
    short status = ISO7816.SW_NO_ERROR;
    // First check whether there is any space remaining in the apdu buffer.
    while(index < mContext.mChunkSize[0]){
      // if there is any data remaining in context buffer and if yes then copy that to apdu buffer.
      if(mContext.mBufReadIndex[0] < mContext.mBufWriteIndex[0]){
        len = transferData(buf, index, mContext.mChunkSize[0]);
        // Remaining bytes to be sent is equal to
        // remaining bytes to be encoded from presentation package +
        // remaining encrypted data in context buffer +
        // remaining un encrypted data in Session's encryption buffer +
        // 16 bytes of auth tag.
        short remBytes = (short)(
                mContext.mRemainingBytes[0] +
                mContext.mBufWriteIndex[0] - mContext.mBufReadIndex[0] +
                Session.mBuffer[Session.BUF_LENGTH_OFFSET] +
                SEProvider.AES_GCM_TAG_LENGTH);
        // Calculate the status.
        if( remBytes > 256){
          status = ISO7816.SW_BYTES_REMAINING_00;
        }else if(remBytes > 0){
          status = (short) (ISO7816.SW_BYTES_REMAINING_00 | (byte)remBytes);
        }else if(remBytes < 0){
          ISOException.throwIt(ISO7816.SW_UNKNOWN);
        }else{
          status = ISO7816.SW_NO_ERROR;
        }
        // advance the current pointer in the apdu buffer.
        index += len;
      }else if(mContext.mRemainingBytes[0] > 0){ // There is remaining data required to be encoded.
        // Context buffer is empty,
        // So encode new data by reading the package. This will increment write pointer.
        // Then encrypt the data which may be upto 16 bytes less if the data is not block aligned.
        mContext.mBufWriteIndex[0] = mContext.mBufReadIndex[0] = 0;
        // If there is any buffered data in encryption session then copy that.
        mContext.mBufWriteIndex[0] += Session.readAndClearBufferedData(mContext.mBuffer,
            mContext.mBufWriteIndex[0]);
        mEncoder.init(
            mContext.mBuffer, mContext.mBufWriteIndex[0], (short) (mContext.mBuffer.length));
        // Encode data from presentation package and copy that in context buffer.
        short encodedLen = encodeData(mEncoder);
        SEProvider.print( mContext.mBuffer, mContext.mBufWriteIndex[0],encodedLen);
        mContext.mRemainingBytes[0] -= encodedLen;
        mContext.mBufWriteIndex[0] += encodedLen;

        // Encrypt all the data from 0 to write index.
        // Encrypt in place. The returned data can be less than the input data if the data is not
        // blocked aligned.
        mContext.mBufWriteIndex[0] = Session.encryptDataIncrementally(
            mContext.mBuffer, (short)0, mContext.mBufWriteIndex[0],
            mScratchPad, (short)0, (short)mScratchPad.length);
      } else if(mContext.mRemainingBytes[0] == 0){// Nothing to encode
        // If there is any buffered data in encryption session then copy that.
        mContext.mBufReadIndex[0] = 0;
        mContext.mBufWriteIndex[0] = Session.readAndClearBufferedData(mContext.mBuffer, (short) 0);
        mContext.mBufWriteIndex[0] = Session.finishIncrementalEncryption(
            mContext.mBuffer, (short)0, mContext.mBufWriteIndex[0]);
        Session.mBuffer[Session.BUF_LENGTH_OFFSET] = 0;
        mContext.mRemainingBytes[0] = -SEProvider.AES_GCM_TAG_LENGTH;
      } else{
        // no more data to process
        mContext.mRemainingBytes[0] = 0;
        break;
      }
    }
    sendBytes(apdu, (short) 0, index, status);
  }

  /**
   * IssuerSigned = {
   * ? "nameSpaces" : IssuerNameSpaces, ; Returned data elements
   * "issuerAuth" : IssuerAuth ; Contains the mobile security object (MSO)
   * ; for issuer data authentication
   * }
   * This method only encodes start of map and issuerAuth key.
   *
   */
  static short encodeIssuerSigned(CBOREncoder encoder, DocumentRequest request) {
    short start = encoder.getCurrentOffset();
    encoder.encodeRawData(MdlSpecifications.issuerSigned, (short) 0,
        (short) MdlSpecifications.issuerSigned.length);
    encoder.startMap((short) 2);
    encoder.encodeRawData(MdlSpecifications.issuerAuth, (short) 0,
        (short) MdlSpecifications.issuerAuth.length);
    return (short)(encoder.getCurrentOffset() - start);
  }

  static short encodeNs(CBOREncoder encoder, DocumentRequest request, short nsIndex) {
    short start = encoder.getCurrentOffset();
    byte[] nsId = request.getNsId(nsIndex);
    encoder.encodeRawData(nsId,(short)0, (short)nsId.length);
    encoder.startArray(request.getElementCountForNs(nsIndex));
    return (short) (encoder.getCurrentOffset() - start);
  }

  // Note: end = start + length
  static short encodeBytes(CBOREncoder encoder, byte[] buf, short start, short end){
    short len = (short)(end - start);
    short bufLen = (short)(encoder.getBufferLength() - encoder.getCurrentOffset());
    if(len > bufLen){
      len = bufLen;
    }
    encoder.encodeRawData(buf, start, len);
    return len;
  }

  /** This is the response specific state machine.
   * Note: This is only valid for Device Response schema specified in Mdl specifications.
   * Every switch case is one state and they do two things:
   * 1) action: Does the action required for the current state - mainly encoding the keys of
   * this node and sometime child nodes.
   * 2) change to next state: Sets transition to next state. The next state can be either root
   * node or child node value.
   *
   **/
  private static short encodeResponse(CBOREncoder encoder){
      short len = 0;
      switch (mContext.mIncrementalResponseState[Context.CURRENT_STATE]) {
        case Context.RESP_IDLE:
          return (short)0;
        case Context.RESP_START:
          // Encodes common device response.
          len = encodeDeviceResponseStartSuccess(encoder, mContext.mDocumentsCount[0]);
          if(mContext.mDocumentsCount[0] > 0) {
            mContext.mIncrementalResponseState[Context.CURRENT_DOC] = 0;
            mContext.mIncrementalResponseState[Context.CURRENT_ELEMENT] = 0;
            mContext.mIncrementalResponseState[Context.CURRENT_NAMESPACE] = 0;
            mContext.mIncrementalResponseState[Context.CURRENT_DATA_PTR_END] = 0;
            mContext.mIncrementalResponseState[Context.CURRENT_DATA_PTR_START] = 0;
            mContext.mIncrementalResponseState[Context.CURRENT_STATE] = Context.RESP_DOCUMENT;
          }
          break;
        case Context.RESP_DOCUMENT: {
          short docIndex = mContext.mIncrementalResponseState[Context.CURRENT_DOC];
          if (docIndex < mContext.mDocumentsCount[0]) {
            DocumentRequest request = (DocumentRequest)mContext.mDocumentRequests[docIndex];
            if(request == null){
              ISOException.throwIt(ISO7816.SW_CONDITIONS_NOT_SATISFIED);
            }
            // The package is the main tree from where we want to source the data.
            MdocPresentationPkg pkg = request.getDocument();
            if(pkg == null){
              ISOException.throwIt(ISO7816.SW_CONDITIONS_NOT_SATISFIED);
            }
            mContext.mDocuments[0] = request;
            len = encodeDocumentStart(encoder, request);
            mContext.mIncrementalResponseState[Context.CURRENT_STATE] = Context.RESP_DEVICE_SIGNED;
          } else {
            mContext.mIncrementalResponseState[Context.CURRENT_DOC] = 0;
            mContext.mDocuments[0] = mContext.mDocumentRequests[docIndex];
            mContext.mIncrementalResponseState[Context.CURRENT_STATE] = Context.RESP_IDLE;
          }
        }
          break;
        case Context.RESP_DEVICE_SIGNED: {
          len = encodeDeviceSigned(encoder, (DocumentRequest) mContext.mDocuments[0]);
          mContext.mIncrementalResponseState[Context.CURRENT_STATE] = Context.RESP_ISSUER_SIGNED;
        }
          break;
        case Context.RESP_ISSUER_SIGNED: {
            DocumentRequest request = (DocumentRequest)mContext.mDocuments[0];
            len = encodeIssuerSigned(encoder, request);
            short authStart = request.getDocument().getIssuerAuthStart();
            short authEnd = (short) (authStart + request.getDocument().getIssuerAuthLength());
            mContext.mIncrementalResponseState[Context.CURRENT_DATA_PTR_START] = authStart;
            mContext.mIncrementalResponseState[Context.CURRENT_DATA_PTR_END] = authEnd;
            mContext.mIncrementalResponseState[Context.CURRENT_STATE] = Context.RESP_ISSUER_AUTH;
        }
          break;
        case Context.RESP_ISSUER_AUTH: {
          DocumentRequest request = (DocumentRequest)mContext.mDocuments[0];
          len = encodeBytes(encoder, request.getDocument().getBuffer(),
              mContext.mIncrementalResponseState[Context.CURRENT_DATA_PTR_START],
              mContext.mIncrementalResponseState[Context.CURRENT_DATA_PTR_END]);
          mContext.mIncrementalResponseState[Context.CURRENT_DATA_PTR_START] += len;
          if (mContext.mIncrementalResponseState[Context.CURRENT_DATA_PTR_START] ==
              mContext.mIncrementalResponseState[Context.CURRENT_DATA_PTR_END]) {
            mContext.mIncrementalResponseState[Context.CURRENT_DATA_PTR_START] =
                mContext.mIncrementalResponseState[Context.CURRENT_DATA_PTR_END] = 0;
            if (request.getNsCount() > 0) {
              len += encoder.encodeRawData(MdlSpecifications.nameSpaces, (short) 0,
                  (short) MdlSpecifications.nameSpaces.length);
              short offset = encoder.getCurrentOffset();
              len += (short) (encoder.startMap(request.getNsCount()) - offset);
              mContext.mIncrementalResponseState[Context.CURRENT_STATE] = Context.RESP_ISSUER_NS;
            } else {
              mContext.mIncrementalResponseState[Context.CURRENT_DOC]++;
              mContext.mIncrementalResponseState[Context.CURRENT_STATE] = Context.RESP_DOCUMENT;
            }
          }
        }
          break;
        case Context.RESP_ISSUER_NS: {
          DocumentRequest request = (DocumentRequest)mContext.mDocuments[0];
          short nsIndex = mContext.mIncrementalResponseState[Context.CURRENT_NAMESPACE];
          if (nsIndex < request.getNsCount()) {
            mContext.mIncrementalResponseState[Context.CURRENT_ELEMENT] = 0;
            mContext.mIncrementalResponseState[Context.CURRENT_STATE] = Context.RESP_NS_ELEMENTS;
            mContext.mIncrementalResponseState[Context.CURRENT_ELEMENT] = 0;
            len = encodeNs(encoder, request, nsIndex);
          }else {
            mContext.mIncrementalResponseState[Context.CURRENT_ELEMENT] = 0;
            mContext.mIncrementalResponseState[Context.CURRENT_NAMESPACE] = 0;
            mContext.mIncrementalResponseState[Context.CURRENT_DATA_PTR_END] = 0;
            mContext.mIncrementalResponseState[Context.CURRENT_DATA_PTR_START] = 0;
            mContext.mIncrementalResponseState[Context.CURRENT_DOC]++;
            mContext.mIncrementalResponseState[Context.CURRENT_STATE] = Context.RESP_DOCUMENT;
          }
        }
          break;
        case Context.RESP_NS_ELEMENTS: {
          DocumentRequest request = (DocumentRequest) mContext.mDocuments[0];
          short nsIndex = mContext.mIncrementalResponseState[Context.CURRENT_NAMESPACE];
          short elemIndex = mContext.mIncrementalResponseState[Context.CURRENT_ELEMENT];
          if (elemIndex < request.getElementCountForNs(nsIndex)) {
            short elemStart = request.getElementStart(nsIndex, elemIndex);
            short elemEnd = (short) (elemStart + request.getElementLen(nsIndex, elemIndex));
            mContext.mIncrementalResponseState[Context.CURRENT_DATA_PTR_START] = elemStart;
            mContext.mIncrementalResponseState[Context.CURRENT_DATA_PTR_END] = elemEnd;
            mContext.mIncrementalResponseState[Context.CURRENT_STATE] = Context.RESP_NS_ELEMENT;
          } else {
            mContext.mIncrementalResponseState[Context.CURRENT_NAMESPACE]++;
            mContext.mIncrementalResponseState[Context.CURRENT_STATE] = Context.RESP_ISSUER_NS;
          }
        }
          break;
        case Context.RESP_NS_ELEMENT: {
          DocumentRequest request = (DocumentRequest) mContext.mDocuments[0];
          len = encodeBytes(encoder, request.getDocument().getBuffer(),
              mContext.mIncrementalResponseState[Context.CURRENT_DATA_PTR_START],
              mContext.mIncrementalResponseState[Context.CURRENT_DATA_PTR_END]);
          mContext.mIncrementalResponseState[Context.CURRENT_DATA_PTR_START] += len;
          if (mContext.mIncrementalResponseState[Context.CURRENT_DATA_PTR_START] ==
              mContext.mIncrementalResponseState[Context.CURRENT_DATA_PTR_END]) {
            mContext.mIncrementalResponseState[Context.CURRENT_DATA_PTR_START] =
                mContext.mIncrementalResponseState[Context.CURRENT_DATA_PTR_END] = 0;
            mContext.mIncrementalResponseState[Context.CURRENT_ELEMENT]++;
            mContext.mIncrementalResponseState[Context.CURRENT_STATE] = Context.RESP_NS_ELEMENTS;
          }
        }
          break;
        default:
          ISOException.throwIt(ISO7816.SW_CONDITIONS_NOT_SATISFIED);
          break;
      }
      return len;
  }

    /*
    // Now send next chunk of bytes from context header
    if(Context.mFirstMessage[0]){
      if(Context.mChunkSize[0] == 0){
        Context.mChunkSize[0] = le;
        Context.mBufIndex[0] = 4; // reserve 4 bytes for envelope header
        byte start = (byte)0;
        Context.mBufLength[0] = 0;
        //make the start of device response as per the context.
        Context.mRemainingBytes[0] = startDeviceResponse();
        //calculate the rest of the length
        Context.mRemainingBytes[0] += calculateIssuerSigned();
        // calculate final header len
        short headerLen = getHeaderLength(Context.mRemainingBytes[0]);
        // add the envelope header
        if(headerLen == 2) {
          Context.mBuffer[2] = (byte)0x53;
          Context.mBuffer[3] = (byte)Context.mRemainingBytes[0];
          start=2;
        }else if(headerLen == 3) {
          Context.mBuffer[1] = (byte)0x53;
          Context.mBuffer[2] = (byte)0x81;
          Context.mBuffer[3] = (byte)Context.mRemainingBytes[0];
          start = 1;
        }else {
          Context.mBuffer[0] = (byte)0x53;
          Context.mBuffer[1] = (byte)0x82;
          Util.setShort(Context.mBuffer, (short) 2, (byte)Context.mRemainingBytes[0]);
        }
        // Add Session data header
        len -= index;
        mEncoder.init(buf, index, len);
        mEncoder.startMap((short) 1);
        //add map
        //add "data" key
        mEncoder.encodeRawData(MdlSpecifications.session_data, (short) 0,
            (short)(MdlSpecifications.session_data.length));
        // add cbor byte string
        mEncoder.startByteString(Context.mRemainingBytes[0]);

      }else{
        // If chunk size is already set then
        ISOException.throwIt(ISO7816.SW_DATA_INVALID);
      }
    }
    short len =Context.mChunkSize[0];
    short index = 0;
    // Add Envelope header
    if(Context.mFirstMessage[0]){
      Context.mRemainingBytes[0] = startDeviceResponse();
      Context.mRemainingBytes[0] += calculateIssuerSigned();
      short envSize = calculateEnvelopeSize(Context.mRemainingBytes[0]);
      buf[index++] =(byte) 0x53;
      if(envSize < 128) {
        buf[index++] = (byte)envSize;
      }else if(envSize < 256) {
        buf[index++] = (byte)0x81;
        buf[index++] = (byte)envSize;
        }else {
        buf[index++] = (byte)0x82;
        Util.setShort(buf, index, envSize);
      }
      // Add Session data header
      len -= index;
      mEncoder.init(buf, index, len);
      mEncoder.startMap((short) 1);
      //add map
      //add "data" key
      mEncoder.encodeRawData(MdlSpecifications.session_data, (short) 0,
          (short)(MdlSpecifications.session_data.length));
      // add cbor byte string
      mEncoder.startByteString(Context.mRemainingBytes[0]);
    }else{
      mEncoder.init(buf, index, len);
    }

    Context.mRemainingBytes[0] -= (short) (mEncoder.getCurrentOffset() - index);
    boolean lastChunk = false;
    if(mEncoder.getCurrentOffset() <= (short) (Context.mChunkSize[0] - SEProvider.AES_GCM_TAG_LENGTH)){
      lastChunk = true;
    }else {
      lastChunk = false;
    }
    sendBytesLong(apdu, buf, index, len, lastChunk, Context.mRemainingBytes[0]);
    */


/*
  public short readBytes(byte[] buf, short start, short len) {
    short index = start;
    short bytesRead = 0;
    switch (mChunkOffsets[CHUNK_STATE]) {
      case READING_DOC_TYPE:
        bytesRead = readDocType(buf, index, len);
        mChunkOffsets[CHUNK_STATE] = READING_ISSUER_SIGNED;
        mChunkOffsets[CHUNK_CURSOR] = mIssuerSignedStart;
        break;
      case READING_ISSUER_SIGNED:
        bytesRead = readIssuerSigned(buf, index, len);
        if(mChunkOffsets[CHUNK_REMAINING_BYTES] <= (short) (DEVICE_SIGNED_SIZE + mErrorsLen)){
          mChunkOffsets[CHUNK_STATE] = READING_DEVICE_SIGNED;
          mChunkOffsets[CHUNK_CURSOR] = 2;
        }
        break;
      case READING_DEVICE_SIGNED:
        bytesRead = readDeviceSigned(buf, index, len);
        if(mChunkOffsets[CHUNK_REMAINING_BYTES] <= mErrorsLen){
          mChunkOffsets[CHUNK_STATE] = READING_ERRORS;
          mChunkOffsets[CHUNK_CURSOR] = mErrorsStart;
        }
        break;
      case READING_ERRORS:
        bytesRead = readErrors(buf, index, len);
        if(mChunkOffsets[CHUNK_REMAINING_BYTES] == 0){
          mChunkOffsets[CHUNK_STATE] = READING_NONE;
          mChunkOffsets[CHUNK_CURSOR] = ICConstants.INVALID_VALUE;
        }
        break;
    }
    index += bytesRead;
    len = (short) (len - bytesRead);
    if(len > 0 && mChunkOffsets[CHUNK_STATE] != READING_NONE){
      bytesRead += readBytes(buf, index, len);
    }
    return bytesRead;
  }

 */
  private static void sendBytesLong(
      APDU apdu, byte[] buffer, short start, short len, boolean lastChunk, short remainingLen) {
    short status = 0;
    if (!lastChunk) {
      if (remainingLen != 0) {
        status = (short) (ISO7816.SW_BYTES_REMAINING_00 | mContext.mRemainingBytes[0]);
      } else {
        status = ISO7816.SW_BYTES_REMAINING_00;
      }
    }
    apdu.setOutgoingLength(len);
    apdu.sendBytesLong(buffer, start, len);
    if(status != 0) {
      ISOException.throwIt(status);
    }
  }
  private static void sendBytes(APDU apdu, short start, short len, short status) {
    apdu.setOutgoingLength(len);
    apdu.sendBytes(start, len);
    if(status != ISO7816.SW_NO_ERROR) {
      ISOException.throwIt(status);
    }else{
      mContext.reset();
    }
  }

/*
  private static void sendBytes(APDU apdu, byte[] buffer, short start, short len,
      boolean firstMessage) {
    short le = apdu.setOutgoing();
    if(firstMessage && mChunkSize[0] != 0){
      len = encapsulateResponse(mBuffer, start, len, MdlUtil.mRetVal);
      mChunkSize[0] = le;
    }
    short chunkSize = mChunkSize[0];
    if (len <= chunkSize) {
      len = performDeviceAuth(buffer, start, len);
      len = encryptDecryptData(buffer, start, len, mDeviceKey, mMsgCounter[DEVICE_MSG_COUNTER],
          true, MdlUtil.mRetVal, false);
      apdu.setOutgoingLength(len);
      apdu.sendBytesLong(buffer, start, len);
      mBufLength[0] = mBufIndex[0] = 0;
      return;
    } else {
      len = encryptDecryptData(buffer, start, len, mDeviceKey, mMsgCounter[DEVICE_MSG_COUNTER],
          true, MdlUtil.mRetVal, true);
      apdu.setOutgoingLength(chunkSize);
      apdu.sendBytesLong(buffer, start, chunkSize);
      if (len < (short) (chunkSize + 255)) {
        ISOException.throwIt((short) (ISO7816.SW_BYTES_REMAINING_00 | len));
      } else {
        ISOException.throwIt((short) (ISO7816.SW_BYTES_REMAINING_00));
      }
    }
    //TODO change this
  }
  */

  private static short sendBytesLong(APDU apdu, byte[] buffer, short start, short len) {
    boolean justUpdate = true;
    if (len <= mContext.mChunkSize[0]) {
      len = Session.encryptDecryptData(buffer, start, len, Session.mDeviceKey, mMsgCounter[DEVICE_MSG_COUNTER],
          true, mRetVal, false);
      apdu.setOutgoingLength(len);
      apdu.sendBytesLong(buffer, start, len);
    } else {
      len = mContext.mChunkSize[0];
      len = Session.encryptDecryptData(buffer, start, len, Session.mDeviceKey, mMsgCounter[DEVICE_MSG_COUNTER],
          true, mRetVal, true);
      apdu.setOutgoingLength(len);
      apdu.sendBytesLong(buffer, start, len);
    }
    mMsgCounter[DEVICE_MSG_COUNTER]++;
    return len;
  }

  // -------- MdlService Interface implementation
  @Override
  public Shareable getShareableInterfaceObject(AID clientAID, byte parameter) {
    byte[] buf = new byte[16];
    byte len = clientAID.getBytes(buf, (short)0);
    if(Util.arrayCompare(buf,(short)0, AID_NDEF_TAG_APPLET,(short) 0,len) !=0) {
      ISOException.throwIt(ISO7816.SW_WRONG_DATA);
    }
    return this;
  }

  @Override
  public short getHandoverSelectMessage(byte[] buf, short start) {
    if(buf == null || (short)buf.length < (short)( start +
        HANDOVER_MSG_FIXED_PART.length +
        DEVICE_ENGAGEMENT_FIXED.length +
        MdlSpecifications.EC_P256_COSE_KEY_SIZE)){
      ISOException.throwIt(ISO7816.SW_WRONG_LENGTH);
    }

    short offset = Util.arrayCopyNonAtomic(HANDOVER_MSG_FIXED_PART, (short)0, buf, start,
        (byte) HANDOVER_MSG_FIXED_PART.length);
    byte payloadLenOffset = (byte)(offset - MDOC_ID_LEN - MDOC_TYPE_LEN - 2);
    offset = Util.arrayCopyNonAtomic(DEVICE_ENGAGEMENT_FIXED, (short)0,buf, offset,
        (short)DEVICE_ENGAGEMENT_FIXED.length);

    // Currently, only p256 EC keys are supported.
    offset = Session.generateAndAddEDeviceKey_p256(buf, offset);
    short len = (short)(offset - start);
    // Payload length will be always less than 256 for p256 keys.
    buf[payloadLenOffset] = (byte)(len - (short) HANDOVER_MSG_FIXED_PART.length);
    if(buf[payloadLenOffset] > 255){
      ISOException.throwIt(ISO7816.SW_UNKNOWN);
    }
    Util.arrayCopyNonAtomic(buf, start, Session.mHandover, (short)8, len);
    Util.setShort(Session.mHandover, Session.HANDOVER_MSG_START, (short)8);
    Util.setShort(Session.mHandover, Session.HANDOVER_MSG_LEN, len);
    Util.setShort(Session.mHandover, Session.DEVICE_ENGAGEMENT_START, (short) (HANDOVER_MSG_FIXED_PART.length + 8));
    Util.setShort(Session.mHandover, Session.DEVICE_ENGAGEMENT_LEN, buf[payloadLenOffset]);
    return len;
  }

/* If payload length is > 256 then the following logic applies.
   static final byte DISABLE_SHORT_RECORD = (byte)0xEF;
   else{ // payload length is not short hence we need to fix the Ndef File.
    // Disable the short record bit
    byte mdocNdefFlags = (byte)(payloadLenOffset - 2);
    mNdefDataFile[mdocNdefFlags] &= DISABLE_SHORT_RECORD;

    // Adjust to the long payload format by expanding the payload len from 1 byte to 4 bytes
    SEProvider.arrayCopyNonAtomic(mNdefDataFile, payloadLenOffset, mNdefDataFile,
    (short)(payloadLenOffset + 3), payloadLength);
    SEProvider.setShort(mNdefDataFile, payloadLenOffset, (short)0);
    payloadLenOffset += 2;
    SEProvider.setShort(mNdefDataFile, payloadLenOffset, payloadLength);

    // Ndef data file length will also increase by 3.
    ndefDataFileLen += 3;
*/

/*
    // Now, create deviceAuth structure which will include the signature
    short offset = Util.arrayCopyNonAtomic(DEVICE_SIGNED, (short)0, mDeviceSignedWithAuth, (short)2,
        (short) DEVICE_SIGNED.length);
    SEProvider.print(mDeviceSignedWithAuth, (short) 2, (short)(offset - 2));
    // Add the signature at the offset which points to the start of signature value of 32 bytes
    offset = Util.arrayCopyNonAtomic(scratchPad, index, mDeviceSignedWithAuth, offset, signLen);
    // Done... the offset which is also the length of the deviceAuth. During document
    // presentation this length will be used to append the device auth while incrementally
    // returning the mdl document.
    Util.setShort(mDeviceSignedWithAuth, (short)0, (short) (offset-2));
    SEProvider.print(mDeviceSignedWithAuth, (short) 2, Util.getShort(mDeviceSignedWithAuth,
        (short)0));
  }
 */

}
